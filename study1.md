
# solid 원칙

SOLID 원칙은 객체 지향 프로그래밍의 설계 원칙을 나타냅니다. 이 원칙들은 소프트웨어를 설계하고 구현할 때 더 견고하고 유연하며 확장 가능하도록 도와줍니다. SOLID는 다음 다섯 가지 원칙으로 구성됩니다.

---

### 1. **단일 책임 원칙 (Single Responsibility Principle, SRP)**

단일 책임 원칙은 클래스나 모듈이 하나의 책임만을 가져야 한다는 원칙입니다. 이것은 "하나의 책임"을 어떻게 정의하느냐에 따라 해석이 다를 수 있습니다. 보통 "변경의 이유"로 정의됩니다. 즉, 클래스가 변경되어야 하는 이유는 오직 하나여야 합니다.
- **응집도가 높음(Cohesion)**: 클래스나 모듈은 하나의 목적에 집중되어 있으며, 그 목적을 위해 필요한 모든 기능을 포함하고 있습니다.
- **변경에 대한 안정성(Support for Change)**: 클래스나 모듈은 특정 책임을 담당하고 있으므로 해당 책임에 관련된 변경에 대해 안정적입니다. 즉, 다른 책임을 변경할 필요 없이 해당 책임에만 집중하여 변경할 수 있습니다.
- 
단일 책임 원칙은 클래스나 모듈이 하나의 일만을 잘 처리하도록 하여 코드의 이해와 유지보수를 쉽게 만들어주는 원칙입니다. 클래스나 모듈을 설계할 때 어떤 일을 수행해야 하는지 명확히 정의하고, 각각의 클래스나 모듈이 그 일을 완벽하게 수행하도록 하는 것이 중요합니다.

---

### 2. **개방-폐쇄 원칙 (Open-Closed Principle, OCP)**

개방 폐쇄 원칙(Open/Closed Principle, OCP)은 소프트웨어 개체(클래스, 모듈, 함수 등)는 확장에 대해 개방적이어야 하고, 수정에 대해서는 폐쇄적이어야 한다는 원칙입니다. 이는 소프트웨어 개체는 기존 코드를 변경하지 않고도 새로운 기능을 추가할 수 있어야 한다는 의미를 가지고 있습니다.

- **개방(Open for Extension)**
	1. 새로운 기능이나 요구 사항이 추가되어도 기존의 코드를 변경하지 않고 기능을 확장할 수 있어야 합니다.
	2. 기능을 확장하는 방법은 주로 다형성, 상속, 컴포지션 등을 사용하여 구현됩니다.
	3. 새로운 기능을 추가할 때, 기존의 코드를 수정하지 않고도 새로운 클래스나 모듈을 추가하여 기능을 확장할 수 있어야 합니다.
- **폐쇄 (Closed for Modification)**
	1.  이미 동작하는 코드는 변경하지 않아야 합니다. 이는 기존의 코드가 안정적으로 동작하고 있는 상태를 유지하는 것을 의미합니다.
	2. 새로운 기능을 추가할 때 기존의 코드를 수정하면, 기존의 기능이나 동작에 영향을 줄 수 있으며, 이는 코드의 안정성과 신뢰성을 저하시킬 수 있습니다.

- 개방 폐쇄 원칙은 초기에 설계 단계에서 고려되어야 합니다. 적절한 추상화와 인터페이스 설계를 통해 개방 폐쇄 원칙을 준수할 수 있습니다.
- 좋은 설계가 없는 경우 개방 폐쇄 원칙을 준수하기가 어려울 수 있습니다. 따라서 설계를 신중하게 고려하여야 합니다.

개방 폐쇄 원칙을 준수하면 코드의 유연성이 향상되고, 변경에 대한 안정성이 높아집니다. 새로운 기능이나 요구 사항이 추가되더라도 기존의 코드를 변경하지 않고도 기능을 확장할 수 있으므로, 코드의 재사용성과 유지보수성이 향상됩니다.

---

### 3.  **리스코프 치환 원칙 (Liskov Substitution Principle, LSP)**

리스코프 치환 원칙(Liskov Substitution Principle, LSP)은 객체 지향 프로그래밍에서 상속을 사용할 때 지켜야 하는 원칙 중 하나입니다. 리스코프 치환 원칙은 하위 클래스(derived class)는 상위 클래스(base class)의 역할을 완전히 대체할 수 있어야 한다는 원칙을 나타냅니다.

리스코프 치환 원칙은 다음과 같이 정의됩니다:

"하위 타입(subtype)은 언제나 상위 타입(super type)으로 교체할 수 있어야 한다."

```java
class Shape {
    public void draw() {
        System.out.println("도형을 그립니다.");
    }
}

class Circle extends Shape {
    @Override
    public void draw() {
        System.out.println("원을 그립니다.");
    }
}
```

1. 상위 클래스와 하위 클래스의 관계
2. 하위 클래스는 상위 클래스의 모든 기능을 정확하게 구현해야 합니다. 즉, 상위 클래스의 메서드를 오버라이드할 때는 그 기능을 완전히 대체해야 합니다.
3. 클라이언트 코드에서 상위 클래스의 객체를 사용하는 부분에서는 하위 클래스의 객체를 대신 사용해도 문제가 없어야 합니다.

```java
public class Main {
    public static void main(String[] args) {
        Shape shape = new Circle();
        shape.draw(); // "원을 그립니다."가 출력됩니다.
    }
}
```

위의 코드에서 `Shape` 클래스의 객체를 생성할 때 실제로는 `Circle` 클래스의 인스턴스가 생성되었습니다. 이후에 `draw()` 메서드를 호출할 때도 실제로는 `Circle` 클래스의 `draw()` 메서드가 호출됩니다. 이렇게 하위 클래스의 객체가 상위 클래스의 객체로 대체되어도 프로그램의 동작에 아무런 문제가 없습니다.

이것이 리스코프 치환 원칙(Liskov Substitution Principle)의 핵심입니다. 하위 클래스는 상위 클래스의 역할을 완전히 대체할 수 있어야 하며, 이로 인해 클라이언트 코드에서는 하위 클래스를 상위 클래스로 취급하여 사용할 수 있어야 합니다.

---

### 4.  **인터페이스 분리 원칙 (Interface Segregation Principle, ISP)**

인터페이스 분리 원칙(Interface Segregation Principle, ISP)은 소프트웨어 디자인에서 인터페이스를 설계할 때 지켜야 하는 원칙 중 하나입니다. ISP는 클라이언트가 자신이 사용하지 않는 메서드에 의존하지 않아야 한다는 것을 강조합니다. 즉, 한 인터페이스에 많은 메서드를 포함시키는 것보다는 클라이언트가 필요로 하는 작은 단위의 인터페이스로 분리하는 것이 좋다는 원칙입니다.

1. **클라이언트 의존성 최소화**: 클라이언트는 자신이 필요로 하는 기능에만 의존해야 합니다. 따라서 클라이언트가 사용하지 않는 메서드가 포함된 인터페이스에 의존하는 것을 방지하여 의존성을 최소화해야 합니다.
2. **인터페이스의 유연성과 재사용성 향상**: 작은 단위의 인터페이스로 분리함으로써 인터페이스의 유연성과 재사용성을 향상시킬 수 있습니다. 이는 인터페이스가 더 적은 기능에 대해서만 책임을 갖게 되므로, 이를 구현하는 클래스는 자신이 필요한 인터페이스만 구현하면 되기 때문입니다.

---

### 5.  **의존 역전 원칙 (Dependency Inversion Principle, DIP)**
  
의존 역전 원칙(Dependency Inversion Principle, DIP)은 객체 지향 프로그래밍에서 소프트웨어 모듈 간의 의존성을 최소화하기 위한 원칙입니다. 이 원칙은 높은 수준의 모듈이 낮은 수준의 모듈에 의존해서는 안 되며, 두 모듈 모두 추상화에 의존해야 한다는 것을 강조합니다. 즉, 상위 수준의 모듈은 하위 수준의 모듈에 의존하지 않고, 모두 추상화에 의존해야 한다는 것입니다.

1. 고수준 모듈은 저수준 모듈에 의존해서는 안 된다. 두 모듈 모두 추상화에 의존해야 한다.
2. 추상화는 세부 사항에 의존해서는 안 된다. 세부 사항은 추상화에 의존해야 한다.

- **유연성 향상:** 변화에 영향을 받는 모듈을 최소화하여 코드의 유연성을 높입니다.
- **확장성 향상:** 새로운 기능 추가나 변경이 쉬워집니다.
- **테스트 용이성 향상:** 모듈 간의 의존 관계가 명확해져 테스트가 용이해집니다.
- **결합도 감소:** 모듈 간의 결합도가 낮아져 코드 관리가 용이해집니다.

의존 역전 원칙은 유연하고 확장 가능한 소프트웨어를 설계하는 데 중요한 역할을 합니다.



##### 이러한 SOLID 원칙은 객체 지향 설계의 기초를 이루며, 코드의 유지 보수성, 재사용성, 확장성을 향상시킵니다. 이 원칙들을 준수함으로써 코드의 품질을 향상시키고, 잠재적인 버그를 줄이며, 개발자들 간의 협업을 용이하게 합니다.